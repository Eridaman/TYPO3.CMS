<?php
/***************************************************************
 *  Copyright notice
 *
 *  (c) 2011 Helmut Hummel <helmut.hummel@typo3.org>
 *  All rights reserved
 *
 *  This script is part of the TYPO3 project. The TYPO3 project is
 *  free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  The GNU General Public License can be found at
 *  http://www.gnu.org/copyleft/gpl.html.
 *  A copy is found in the textfile GPL.txt and important notices to the license
 *  from the author is found in LICENSE.txt distributed with these scripts.
 *
 *
 *  This script is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  This copyright notice MUST APPEAR in all copies of the script!
 ***************************************************************/

/**
 * Randomizer generates random bytes or strings
 *
 *
 * @package TYPO3
 * @subpackage t3lib_security
 * @author Helmut Hummel <helmut.hummel@typo3.org>
 */
class t3lib_security_Randomizer implements t3lib_Singleton {
	/**
	 * Cache for the generated byte stream.
	 *
	 * @var string
	 */
	protected $generatedBytes = '';

	/**
	 * The collection of methods that are implemented
	 * in this class to generate random bytes.
	 * The array is sorted by preferred execution order.
	 *
	 * @var array
	 */
	protected $implementedMethods = array(
			'OpenSsl',
			'McryptUrandom',
			'McryptRand',
			'Urandom',
			'Php',
	);

	/**
	 * These methods do not work or are
	 * very slow on Windows systems.
	 *
	 * @var array
	 */
	protected $methodBlackListWindows = array(
		'OpenSsl',
		'McryptUrandom',
		'Urandom',
	);

	/**
	 * Methods that are available on the system.
	 *
	 * @var array
	 */
	protected $availableMethods = array();


	/**
	 * Populate available methods in constructor
	 */
	public function __construct() {
		$this->populateAvailableMethods();
	}

	/**
	 * Populate available methods that match the system constraints.
	 *
	 * @return void
	 */
	public function populateAvailableMethods() {
		foreach ($this->implementedMethods as $methodSuffix) {
			if ($this->isMethodAvailable($methodSuffix)) {
				$this->availableMethods[] = 'generateRandomBytes' . $methodSuffix;
			}
		}
	}

	/**
	 * Checks if the method is available on this system.
	 *
	 * @param string $methodSuffix
	 * @return bool
	 */
	protected function isMethodAvailable($methodSuffix) {
		$isAvailable = TRUE;

		if ($this->isOnWindowsSystem()) {
			if (in_array($methodSuffix, $this->methodBlackListWindows)) {
				$isAvailable = FALSE;
			}
		} else if ($methodSuffix === 'McryptRand') {
			$isAvailable = FALSE;
		}

		if (t3lib_div::isFirstPartOfStr('Mcrypt', $methodSuffix) && !$this->isMcryptAvailable()) {
			$isAvailable = FALSE;
		}

		return $isAvailable;
	}

	/**
	 * Checks if the needed PHP function is available.
	 * This method is mainly there to be able to mock it in unit tests.
	 *
	 * @return bool
	 */
	protected function isMcryptAvailable() {
		return function_exists('mcrypt_create_iv');
	}

	/**
	 * Check if the current system is Windows.
	 * This method is mainly there to be able to mock it in unit tests.
	 *
	 * @return bool
	 */
	protected function isOnWindowsSystem() {
		return TYPO3_OS === 'WIN';
	}

	/**
	 * Checks if enough bytes are in static byte cache.
	 *
	 * @param integer $count
	 * @return bool
	 */
	protected function hasEnoughGeneratedBytes($count) {
		return isset($this->generatedBytes{$count - 1});
	}

	/**
	 * Returns a string of highly randomized bytes (over the full 8-bit range).
	 *
	 * Note: Returned values are not guaranteed to be crypto-safe,
	 * most likely they are not, depending on the used retrieval method.
	 *
	 * @param integer $count Number of characters (bytes) to return
	 * @return string Random Bytes
	 * @see http://bugs.php.net/bug.php?id=52523
	 * @see http://www.php-security.org/2010/05/09/mops-submission-04-generating-unpredictable-session-ids-and-hashes/index.html
	 */
	public function generateRandomBytes($count) {
		foreach ($this->availableMethods as $method) {
			if ($this->hasEnoughGeneratedBytes($count)) {
				break;
			}
			$this->$method($count);
		}

		if (!$this->hasEnoughGeneratedBytes($count)) {
			throw new UnexpectedValueException('This should never happen!', 1314740184);
		}

		$output = substr($this->generatedBytes, 0, $count);
		$this->generatedBytes = substr($this->generatedBytes, $count);

		return $output;
	}

	/**
	 * Returns a hex representation of a random byte string.
	 *
	 * @param integer $count Number of hex characters to return
	 * @return string Random Bytes
	 */
	public function getRandomHexString($count) {
		return substr(bin2hex($this->generateRandomBytes(intval(($count + 1) / 2))), 0, $count);
	}

	/**
	 * This is the preferred method on non Windows systems
	 * because on Windows openssl seems to be very slow.
	 *
	 * @param integer $count
	 * @return void
	 */
	protected function generateRandomBytesOpenSsl($count) {
		$isStrong = NULL;
		$this->generatedBytes .= openssl_random_pseudo_bytes(max(4096, $count), $isStrong);
	}

	/**
	 * This method could be useful if openssl failed.
	 *
	 * @param $count
	 * @return void
	 */
	protected function generateRandomBytesMcryptUrandom($count) {
		$this->generatedBytes .= $this->getRandomBytesMcrypt($count, MCRYPT_DEV_URANDOM);
	}

	/**
	 * This is the preferred method on Windows systems.
	 *
	 * @param $count
	 * @return void
	 */
	protected function generateRandomBytesMcryptRand($count) {
		$this->generatedBytes .= $this->getRandomBytesMcrypt($count, MCRYPT_RAND);
	}

	/**
	 * This is the preferred method on Windows systems.
	 *
	 * @param $count
	 * @return void
	 */
	protected function getRandomBytesMcrypt($count, $randomSource) {
		return mcrypt_create_iv(max(4096, $count), $randomSource);
	}

	/**
	 * In case openssl or mcrypt failed to create enough random bytes
	 * this method uses the /dev/urandom device if available.
	 *
	 * @param integer $count
	 * @return void
	 */
	protected function generateRandomBytesUrandom($count) {
		if ($fh = @fopen('/dev/urandom', 'rb')) {
				// PHP only performs buffered reads, so in reality it will always read
				// at least 4096 bytes. Thus, it costs nothing extra to read and store
				// that much so as to speed any additional invocations.
			$this->generatedBytes .= fread($fh, max(4096, $count));
			fclose($fh);
		}
	}

	/**
	 * If native PHP or OS methods failed, we generate
	 * somewhat random bytes with PHP code.
	 *
	 * @param integer $count
	 * @return void
	 */
	protected function generateRandomBytesPhp($count) {
			// We initialize with somewhat random.
		$randomState = $GLOBALS['TYPO3_CONF_VARS']['SYS']['encryptionKey'] . base_convert(memory_get_usage() % pow(10, 6), 10, 2) . microtime() . uniqid('') . getmypid();
		while (!isset($this->generatedBytes{$count - 1})) {
			$randomState = sha1(microtime() . mt_rand() . $randomState);
			$this->generatedBytes .= sha1(mt_rand() . $randomState, TRUE);
		}
	}
}